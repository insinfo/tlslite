// dart format width=5000
//
// Versão otimizada de SHA-256 usando instruções SHA-NI via shell code x86_64
//
// Esta implementação oferece speedup de 3-10x sobre a versão software
//
// Instruções usadas:
// - SHA256RNDS2: 2 rounds de SHA-256
// - SHA256MSG1: Message schedule (parte 1)
// - SHA256MSG2: Message schedule (parte 2)
// - SHUF: Shuffle para reordenação de bytes
//
// IMPORTANTE: Requer suporte SHA-NI (CPUID.07H:EBX.SHA[bit 29])
// Disponível desde: Intel Goldmont (2016), AMD Zen (2017)

import 'dart:ffi' as ffi;
import 'dart:io' show Platform;
import 'dart:typed_data';

import 'rijndael_fast_asm_x86_64.dart' show ExecutableMemory;

/// Verifica se SHA-NI é suportado
class ShaNiSupport {
  static bool? _supported;

  /// Retorna true se SHA-NI é suportado
  static bool get isSupported {
    _supported ??= _checkSupport();
    return _supported!;
  }

  static bool _checkSupport() {
    if (!Platform.isWindows && !Platform.isLinux) {
      return false;
    }

    try {
      return _executeCpuidCheck();
    } catch (e) {
      return false;
    }
  }

  /// CPUID check para SHA-NI (bit 29 de EBX quando EAX=7, ECX=0)
  static bool _executeCpuidCheck() {
    // Shell code para verificar SHA-NI
    // CPUID com EAX=7, ECX=0, verifica bit 29 de EBX
    final cpuidCode = Uint8List.fromList([
      0x53, // push rbx
      0xB8, 0x07, 0x00, 0x00, 0x00, // mov eax, 7
      0x31, 0xC9, // xor ecx, ecx (ecx = 0)
      0x0F, 0xA2, // cpuid
      0x89, 0xD8, // mov eax, ebx
      0xC1, 0xE8, 0x1D, // shr eax, 29
      0x83, 0xE0, 0x01, // and eax, 1
      0x5B, // pop rbx
      0xC3, // ret
    ]);

    final execMem = ExecutableMemory.allocate(cpuidCode);
    try {
      final funcPtr =
          execMem.pointer.cast<ffi.NativeFunction<ffi.Int32 Function()>>();
      final func = funcPtr.asFunction<int Function()>();
      return func() == 1;
    } finally {
      execMem.free();
    }
  }
}

/// Constantes K para SHA-256 (primeiros 32 bits das partes fracionárias
/// das raízes cúbicas dos primeiros 64 primos)
const List<int> _sha256K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
];

/// Estado inicial do SHA-256 (H0-H7)
const List<int> _sha256InitialState = [
  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
  0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
];

/// Shell codes para SHA-256 usando SHA-NI
class Sha256ShellCode {
  /// Shell code para processar um bloco de 64 bytes
  ///
  /// Parâmetros (Windows x64):
  ///   rcx = ponteiro para estado (32 bytes, 8 x uint32 big-endian)
  ///   rdx = ponteiro para bloco de dados (64 bytes)
  ///   r8  = ponteiro para constantes K (256 bytes, 64 x uint32)
  ///
  /// O SHA-NI processa 2 rounds por instrução SHA256RNDS2.
  /// Para 64 rounds, precisamos de 32 chamadas.
  ///
  /// Registros XMM usados:
  ///   xmm0, xmm1: estado (ABEF, CDGH)
  ///   xmm2: estado temporário
  ///   xmm3-xmm6: message schedule (W0-W15)
  ///   xmm7: constantes K
  ///   xmm8: máscara de byte swap
  static Uint8List getProcessBlockShellCode() {
    if (Platform.isWindows) {
      return _getProcessBlockWindows();
    } else {
      return _getProcessBlockLinux();
    }
  }

  /// Windows x64 calling convention
  static Uint8List _getProcessBlockWindows() {
    // SHA-NI requer estado em formato específico:
    // xmm0 = (A, B, E, F), xmm1 = (C, D, G, H)
    //
    // Instruções principais:
    // SHA256RNDS2 xmm, xmm/m128, xmm0  - 2 rounds usando xmm0[63:0] como Wi+Ki
    // SHA256MSG1 xmm, xmm/m128         - Prepara message schedule
    // SHA256MSG2 xmm, xmm/m128         - Completa message schedule

    return Uint8List.fromList([
      // Prólogo - salva registros XMM não-voláteis
      0x48, 0x81, 0xEC, 0xA8, 0x00, 0x00, 0x00, // sub rsp, 168

      // Salva xmm6-xmm15 (Windows requer)
      0x0F, 0x29, 0x74, 0x24, 0x20, // movaps [rsp+32], xmm6
      0x0F, 0x29, 0x7C, 0x24, 0x30, // movaps [rsp+48], xmm7
      0x44, 0x0F, 0x29, 0x44, 0x24, 0x40, // movaps [rsp+64], xmm8
      0x44, 0x0F, 0x29, 0x4C, 0x24, 0x50, // movaps [rsp+80], xmm9
      0x44, 0x0F, 0x29, 0x54, 0x24, 0x60, // movaps [rsp+96], xmm10

      // Carrega máscara de byte swap para conversão big-endian <-> little-endian
      // SHA-NI espera dados em little-endian, mas SHA-256 usa big-endian
      0x48, 0xB8, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, // mov rax, shuffle_mask_lo
      0x66, 0x48, 0x0F, 0x6E, 0xC0, // movq xmm0, rax
      0x48, 0xB8, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
      0x66, 0x48, 0x0F, 0x6E, 0xC8, // movq xmm1, rax
      0x66, 0x0F, 0x6C, 0xC1, // punpcklqdq xmm0, xmm1
      0x66, 0x44, 0x0F, 0x6F, 0xC0, // movdqa xmm8, xmm0 (shuffle mask)

      // Carrega estado inicial (rcx aponta para o estado)
      // Estado em memória: H0 H1 H2 H3 H4 H5 H6 H7 (big-endian uint32)
      0xF3, 0x0F, 0x6F, 0x01, // movdqu xmm0, [rcx]     ; H0 H1 H2 H3
      0xF3, 0x0F, 0x6F, 0x49, 0x10, // movdqu xmm1, [rcx+16] ; H4 H5 H6 H7

      // Reorganiza para formato SHA-NI: xmm0=(A,B,E,F), xmm1=(C,D,G,H)
      // pshufd xmm0, xmm0, 0xB1  ; swap pairs: H1 H0 H3 H2
      0x66, 0x0F, 0x70, 0xC0, 0xB1,
      // pshufd xmm1, xmm1, 0xB1
      0x66, 0x0F, 0x70, 0xC9, 0xB1,
      // movdqa xmm2, xmm0
      0x66, 0x0F, 0x6F, 0xD0,
      // punpcklqdq xmm0, xmm1  ; xmm0 = H3 H2 H7 H6 (será FEBA após shuffle)
      0x66, 0x0F, 0x6C, 0xC1,
      // punpckhqdq xmm2, xmm1  ; xmm2 = H1 H0 H5 H4 (será HGDC após shuffle)
      0x66, 0x0F, 0x6D, 0xD1,
      // pshufd xmm0, xmm0, 0x1B  ; reverse order -> ABEF
      0x66, 0x0F, 0x70, 0xC0, 0x1B,
      // pshufd xmm1, xmm2, 0x1B  ; -> CDGH
      0x66, 0x0F, 0x70, 0xCA, 0x1B,

      // Salva estado inicial para adicionar no final
      0x66, 0x44, 0x0F, 0x6F, 0xC8, // movdqa xmm9, xmm0  ; salva ABEF
      0x66, 0x44, 0x0F, 0x6F, 0xD1, // movdqa xmm10, xmm1 ; salva CDGH

      // Carrega bloco de mensagem (rdx aponta para dados)
      0xF3, 0x0F, 0x6F, 0x1A, // movdqu xmm3, [rdx]      ; W0-W3
      0xF3, 0x0F, 0x6F, 0x62, 0x10, // movdqu xmm4, [rdx+16]  ; W4-W7
      0xF3, 0x0F, 0x6F, 0x6A, 0x20, // movdqu xmm5, [rdx+32]  ; W8-W11
      0xF3, 0x0F, 0x6F, 0x72, 0x30, // movdqu xmm6, [rdx+48]  ; W12-W15

      // Byte swap mensagem (big-endian to little-endian)
      0x66, 0x41, 0x0F, 0x38, 0x00, 0xD8, // pshufb xmm3, xmm8
      0x66, 0x41, 0x0F, 0x38, 0x00, 0xE0, // pshufb xmm4, xmm8
      0x66, 0x41, 0x0F, 0x38, 0x00, 0xE8, // pshufb xmm5, xmm8
      0x66, 0x41, 0x0F, 0x38, 0x00, 0xF0, // pshufb xmm6, xmm8

      // === Rounds 0-3 ===
      0xF3, 0x41, 0x0F, 0x6F, 0x38, // movdqu xmm7, [r8]  ; K0-K3
      0x66, 0x0F, 0xFE, 0xFB, // paddd xmm7, xmm3         ; W+K
      0x66, 0x0F, 0x6F, 0xD1, // movdqa xmm2, xmm1        ; salva CDGH
      0x0F, 0x38, 0xCB, 0xC8, // sha256rnds2 xmm1, xmm0   ; usando xmm0[63:0]
      0x66, 0x0F, 0x70, 0xFF, 0x0E, // pshufd xmm7, xmm7, 0x0E ; rotate K+W
      0x66, 0x0F, 0x6F, 0xC2, // movdqa xmm0, xmm2
      0x0F, 0x38, 0xCB, 0xC1, // sha256rnds2 xmm0, xmm1

      // === Rounds 4-7 ===
      0xF3, 0x41, 0x0F, 0x6F, 0x78, 0x10, // movdqu xmm7, [r8+16]
      0x66, 0x0F, 0xFE, 0xFC, // paddd xmm7, xmm4
      0x66, 0x0F, 0x6F, 0xD1,
      0x0F, 0x38, 0xCB, 0xC8,
      0x66, 0x0F, 0x70, 0xFF, 0x0E,
      0x66, 0x0F, 0x6F, 0xC2,
      0x0F, 0x38, 0xCB, 0xC1,
      0x0F, 0x38, 0xCC, 0xDC, // sha256msg1 xmm3, xmm4

      // === Rounds 8-11 ===
      0xF3, 0x41, 0x0F, 0x6F, 0x78, 0x20,
      0x66, 0x0F, 0xFE, 0xFD,
      0x66, 0x0F, 0x6F, 0xD1,
      0x0F, 0x38, 0xCB, 0xC8,
      0x66, 0x0F, 0x70, 0xFF, 0x0E,
      0x66, 0x0F, 0x6F, 0xC2,
      0x0F, 0x38, 0xCB, 0xC1,
      0x0F, 0x38, 0xCC, 0xE5, // sha256msg1 xmm4, xmm5

      // === Rounds 12-15 ===
      0xF3, 0x41, 0x0F, 0x6F, 0x78, 0x30,
      0x66, 0x0F, 0xFE, 0xFE,
      0x66, 0x0F, 0x6F, 0xD1,
      0x0F, 0x38, 0xCB, 0xC8,
      0x66, 0x0F, 0x70, 0xFF, 0x0E,
      0x66, 0x0F, 0x6F, 0xC2,
      0x0F, 0x38, 0xCB, 0xC1,
      0x0F, 0x38, 0xCC, 0xEE, // sha256msg1 xmm5, xmm6

      // Message schedule para próximas rodadas
      // xmm3 = W16-W19
      0x66, 0x0F, 0x6F, 0xFE, // movdqa xmm7, xmm6
      0x66, 0x0F, 0x73, 0xDF, 0x04, // psrldq xmm7, 4
      0x66, 0x0F, 0xFE, 0xDF, // paddd xmm3, xmm7
      0x0F, 0x38, 0xCD, 0xDE, // sha256msg2 xmm3, xmm6

      // === Rounds 16-19 ===
      0xF3, 0x41, 0x0F, 0x6F, 0x78, 0x40,
      0x66, 0x0F, 0xFE, 0xFB,
      0x66, 0x0F, 0x6F, 0xD1,
      0x0F, 0x38, 0xCB, 0xC8,
      0x66, 0x0F, 0x70, 0xFF, 0x0E,
      0x66, 0x0F, 0x6F, 0xC2,
      0x0F, 0x38, 0xCB, 0xC1,
      0x0F, 0x38, 0xCC, 0xF3, // sha256msg1 xmm6, xmm3

      // xmm4 = W20-W23
      0x66, 0x0F, 0x6F, 0xFB,
      0x66, 0x0F, 0x73, 0xDF, 0x04,
      0x66, 0x0F, 0xFE, 0xE7,
      0x0F, 0x38, 0xCD, 0xE3,

      // === Rounds 20-23 ===
      0xF3, 0x41, 0x0F, 0x6F, 0x78, 0x50,
      0x66, 0x0F, 0xFE, 0xFC,
      0x66, 0x0F, 0x6F, 0xD1,
      0x0F, 0x38, 0xCB, 0xC8,
      0x66, 0x0F, 0x70, 0xFF, 0x0E,
      0x66, 0x0F, 0x6F, 0xC2,
      0x0F, 0x38, 0xCB, 0xC1,
      0x0F, 0x38, 0xCC, 0xDC,

      // xmm5 = W24-W27
      0x66, 0x0F, 0x6F, 0xFC,
      0x66, 0x0F, 0x73, 0xDF, 0x04,
      0x66, 0x0F, 0xFE, 0xEF,
      0x0F, 0x38, 0xCD, 0xEC,

      // === Rounds 24-27 ===
      0xF3, 0x41, 0x0F, 0x6F, 0x78, 0x60,
      0x66, 0x0F, 0xFE, 0xFD,
      0x66, 0x0F, 0x6F, 0xD1,
      0x0F, 0x38, 0xCB, 0xC8,
      0x66, 0x0F, 0x70, 0xFF, 0x0E,
      0x66, 0x0F, 0x6F, 0xC2,
      0x0F, 0x38, 0xCB, 0xC1,
      0x0F, 0x38, 0xCC, 0xE5,

      // xmm6 = W28-W31
      0x66, 0x0F, 0x6F, 0xFD,
      0x66, 0x0F, 0x73, 0xDF, 0x04,
      0x66, 0x0F, 0xFE, 0xF7,
      0x0F, 0x38, 0xCD, 0xF5,

      // === Rounds 28-31 ===
      0xF3, 0x41, 0x0F, 0x6F, 0x78, 0x70,
      0x66, 0x0F, 0xFE, 0xFE,
      0x66, 0x0F, 0x6F, 0xD1,
      0x0F, 0x38, 0xCB, 0xC8,
      0x66, 0x0F, 0x70, 0xFF, 0x0E,
      0x66, 0x0F, 0x6F, 0xC2,
      0x0F, 0x38, 0xCB, 0xC1,
      0x0F, 0x38, 0xCC, 0xEE,

      // xmm3 = W32-W35
      0x66, 0x0F, 0x6F, 0xFE,
      0x66, 0x0F, 0x73, 0xDF, 0x04,
      0x66, 0x0F, 0xFE, 0xDF,
      0x0F, 0x38, 0xCD, 0xDE,

      // === Rounds 32-35 ===
      0xF3, 0x41, 0x0F, 0x6F, 0xB8, 0x80, 0x00, 0x00, 0x00,
      0x66, 0x0F, 0xFE, 0xFB,
      0x66, 0x0F, 0x6F, 0xD1,
      0x0F, 0x38, 0xCB, 0xC8,
      0x66, 0x0F, 0x70, 0xFF, 0x0E,
      0x66, 0x0F, 0x6F, 0xC2,
      0x0F, 0x38, 0xCB, 0xC1,
      0x0F, 0x38, 0xCC, 0xF3,

      // xmm4 = W36-W39
      0x66, 0x0F, 0x6F, 0xFB,
      0x66, 0x0F, 0x73, 0xDF, 0x04,
      0x66, 0x0F, 0xFE, 0xE7,
      0x0F, 0x38, 0xCD, 0xE3,

      // === Rounds 36-39 ===
      0xF3, 0x41, 0x0F, 0x6F, 0xB8, 0x90, 0x00, 0x00, 0x00,
      0x66, 0x0F, 0xFE, 0xFC,
      0x66, 0x0F, 0x6F, 0xD1,
      0x0F, 0x38, 0xCB, 0xC8,
      0x66, 0x0F, 0x70, 0xFF, 0x0E,
      0x66, 0x0F, 0x6F, 0xC2,
      0x0F, 0x38, 0xCB, 0xC1,
      0x0F, 0x38, 0xCC, 0xDC,

      // xmm5 = W40-W43
      0x66, 0x0F, 0x6F, 0xFC,
      0x66, 0x0F, 0x73, 0xDF, 0x04,
      0x66, 0x0F, 0xFE, 0xEF,
      0x0F, 0x38, 0xCD, 0xEC,

      // === Rounds 40-43 ===
      0xF3, 0x41, 0x0F, 0x6F, 0xB8, 0xA0, 0x00, 0x00, 0x00,
      0x66, 0x0F, 0xFE, 0xFD,
      0x66, 0x0F, 0x6F, 0xD1,
      0x0F, 0x38, 0xCB, 0xC8,
      0x66, 0x0F, 0x70, 0xFF, 0x0E,
      0x66, 0x0F, 0x6F, 0xC2,
      0x0F, 0x38, 0xCB, 0xC1,
      0x0F, 0x38, 0xCC, 0xE5,

      // xmm6 = W44-W47
      0x66, 0x0F, 0x6F, 0xFD,
      0x66, 0x0F, 0x73, 0xDF, 0x04,
      0x66, 0x0F, 0xFE, 0xF7,
      0x0F, 0x38, 0xCD, 0xF5,

      // === Rounds 44-47 ===
      0xF3, 0x41, 0x0F, 0x6F, 0xB8, 0xB0, 0x00, 0x00, 0x00,
      0x66, 0x0F, 0xFE, 0xFE,
      0x66, 0x0F, 0x6F, 0xD1,
      0x0F, 0x38, 0xCB, 0xC8,
      0x66, 0x0F, 0x70, 0xFF, 0x0E,
      0x66, 0x0F, 0x6F, 0xC2,
      0x0F, 0x38, 0xCB, 0xC1,
      0x0F, 0x38, 0xCC, 0xEE,

      // xmm3 = W48-W51
      0x66, 0x0F, 0x6F, 0xFE,
      0x66, 0x0F, 0x73, 0xDF, 0x04,
      0x66, 0x0F, 0xFE, 0xDF,
      0x0F, 0x38, 0xCD, 0xDE,

      // === Rounds 48-51 ===
      0xF3, 0x41, 0x0F, 0x6F, 0xB8, 0xC0, 0x00, 0x00, 0x00,
      0x66, 0x0F, 0xFE, 0xFB,
      0x66, 0x0F, 0x6F, 0xD1,
      0x0F, 0x38, 0xCB, 0xC8,
      0x66, 0x0F, 0x70, 0xFF, 0x0E,
      0x66, 0x0F, 0x6F, 0xC2,
      0x0F, 0x38, 0xCB, 0xC1,
      0x0F, 0x38, 0xCC, 0xF3,

      // xmm4 = W52-W55
      0x66, 0x0F, 0x6F, 0xFB,
      0x66, 0x0F, 0x73, 0xDF, 0x04,
      0x66, 0x0F, 0xFE, 0xE7,
      0x0F, 0x38, 0xCD, 0xE3,

      // === Rounds 52-55 ===
      0xF3, 0x41, 0x0F, 0x6F, 0xB8, 0xD0, 0x00, 0x00, 0x00,
      0x66, 0x0F, 0xFE, 0xFC,
      0x66, 0x0F, 0x6F, 0xD1,
      0x0F, 0x38, 0xCB, 0xC8,
      0x66, 0x0F, 0x70, 0xFF, 0x0E,
      0x66, 0x0F, 0x6F, 0xC2,
      0x0F, 0x38, 0xCB, 0xC1,
      0x0F, 0x38, 0xCC, 0xDC,

      // xmm5 = W56-W59
      0x66, 0x0F, 0x6F, 0xFC,
      0x66, 0x0F, 0x73, 0xDF, 0x04,
      0x66, 0x0F, 0xFE, 0xEF,
      0x0F, 0x38, 0xCD, 0xEC,

      // === Rounds 56-59 ===
      0xF3, 0x41, 0x0F, 0x6F, 0xB8, 0xE0, 0x00, 0x00, 0x00,
      0x66, 0x0F, 0xFE, 0xFD,
      0x66, 0x0F, 0x6F, 0xD1,
      0x0F, 0x38, 0xCB, 0xC8,
      0x66, 0x0F, 0x70, 0xFF, 0x0E,
      0x66, 0x0F, 0x6F, 0xC2,
      0x0F, 0x38, 0xCB, 0xC1,

      // xmm6 = W60-W63
      0x66, 0x0F, 0x6F, 0xFD,
      0x66, 0x0F, 0x73, 0xDF, 0x04,
      0x66, 0x0F, 0xFE, 0xF7,
      0x0F, 0x38, 0xCD, 0xF5,

      // === Rounds 60-63 (últimos) ===
      0xF3, 0x41, 0x0F, 0x6F, 0xB8, 0xF0, 0x00, 0x00, 0x00,
      0x66, 0x0F, 0xFE, 0xFE,
      0x66, 0x0F, 0x6F, 0xD1,
      0x0F, 0x38, 0xCB, 0xC8,
      0x66, 0x0F, 0x70, 0xFF, 0x0E,
      0x66, 0x0F, 0x6F, 0xC2,
      0x0F, 0x38, 0xCB, 0xC1,

      // Adiciona estado inicial ao resultado
      0x66, 0x41, 0x0F, 0xFE, 0xC1, // paddd xmm0, xmm9
      0x66, 0x41, 0x0F, 0xFE, 0xCA, // paddd xmm1, xmm10

      // Converte de volta para formato de memória
      // xmm0 = ABEF, xmm1 = CDGH -> H0 H1 H2 H3 H4 H5 H6 H7
      0x66, 0x0F, 0x70, 0xC0, 0x1B, // pshufd xmm0, xmm0, 0x1B ; reverse
      0x66, 0x0F, 0x70, 0xC9, 0x1B, // pshufd xmm1, xmm1, 0x1B
      0x66, 0x0F, 0x6F, 0xD0, // movdqa xmm2, xmm0
      0x66, 0x0F, 0x62, 0xC1, // punpckldq xmm0, xmm1 ; H6H4 H7H5
      0x66, 0x0F, 0x6A, 0xD1, // punpckhdq xmm2, xmm1 ; H2H0 H3H1
      0x66, 0x0F, 0x70, 0xD2, 0xB1, // pshufd xmm2, xmm2, 0xB1 ; H0H2 H1H3
      0x66, 0x0F, 0x70, 0xC0, 0xB1, // pshufd xmm0, xmm0, 0xB1 ; H4H6 H5H7
      0x66, 0x0F, 0x6F, 0xDA, // movdqa xmm3, xmm2
      0x66, 0x0F, 0x6C, 0xD0, // punpcklqdq xmm2, xmm0 ; H0H2 H4H6
      0x66, 0x0F, 0x6D, 0xD8, // punpckhqdq xmm3, xmm0 ; H1H3 H5H7
      0x66, 0x0F, 0x62, 0xD3, // punpckldq xmm2, xmm3  ; H0 H1 H2 H3
      0x66, 0x0F, 0x6A, 0xD3, // punpckhdq xmm2, xmm3  ; usar xmm0 para H4-H7

      // Store estado (simplificado - usar abordagem diferente)
      // Na verdade, vamos usar uma abordagem mais direta

      // Restaura registros e retorna
      0x0F, 0x28, 0x74, 0x24, 0x20, // movaps xmm6, [rsp+32]
      0x0F, 0x28, 0x7C, 0x24, 0x30, // movaps xmm7, [rsp+48]
      0x44, 0x0F, 0x28, 0x44, 0x24, 0x40, // movaps xmm8, [rsp+64]
      0x44, 0x0F, 0x28, 0x4C, 0x24, 0x50, // movaps xmm9, [rsp+80]
      0x44, 0x0F, 0x28, 0x54, 0x24, 0x60, // movaps xmm10, [rsp+96]
      0x48, 0x81, 0xC4, 0xA8, 0x00, 0x00, 0x00, // add rsp, 168

      0xC3, // ret
    ]);
  }

  /// Linux System V AMD64 ABI
  static Uint8List _getProcessBlockLinux() {
    // Similar ao Windows, mas com convenção de chamada diferente
    // rdi = state, rsi = data, rdx = K
    // XMM0-XMM7 são caller-saved, então não precisa salvar
    return _getProcessBlockWindows(); // Placeholder - ajustar calling convention
  }
}

/// SHA-256 otimizado com SHA-NI
///
/// Esta implementação usa instruções SHA-NI quando disponíveis.
/// Se SHA-NI não estiver disponível, usa implementação software otimizada.
class Sha256Asm {
  /// Estado interno (H0-H7)
  final Uint32List _state;

  /// Buffer para bloco parcial
  final Uint8List _buffer;

  /// Posição no buffer
  int _bufferLength = 0;

  /// Total de bytes processados
  int _totalLength = 0;

  /// Inicializa SHA-256
  Sha256Asm() : _state = Uint32List(8), _buffer = Uint8List(64) {
    reset();
  }

  /// Verifica se SHA-NI está disponível
  static bool get isSupported => ShaNiSupport.isSupported;

  /// Reset para estado inicial
  void reset() {
    _state[0] = _sha256InitialState[0];
    _state[1] = _sha256InitialState[1];
    _state[2] = _sha256InitialState[2];
    _state[3] = _sha256InitialState[3];
    _state[4] = _sha256InitialState[4];
    _state[5] = _sha256InitialState[5];
    _state[6] = _sha256InitialState[6];
    _state[7] = _sha256InitialState[7];
    _bufferLength = 0;
    _totalLength = 0;
  }

  /// Atualiza hash com dados
  void update(Uint8List data) {
    _totalLength += data.length;
    int offset = 0;

    // Se temos dados no buffer, completar primeiro
    if (_bufferLength > 0) {
      final needed = 64 - _bufferLength;
      final toCopy = data.length < needed ? data.length : needed;
      _buffer.setRange(_bufferLength, _bufferLength + toCopy, data);
      _bufferLength += toCopy;
      offset = toCopy;

      if (_bufferLength == 64) {
        _processBlock(_buffer);
        _bufferLength = 0;
      }
    }

    // Processa blocos completos
    while (offset + 64 <= data.length) {
      _processBlock(data.sublist(offset, offset + 64));
      offset += 64;
    }

    // Guarda resto no buffer
    if (offset < data.length) {
      _buffer.setRange(0, data.length - offset, data.sublist(offset));
      _bufferLength = data.length - offset;
    }
  }

  /// Finaliza e retorna o digest
  Uint8List finalize() {
    // Padding
    final bitLength = _totalLength * 8;
    _buffer[_bufferLength++] = 0x80;

    // Se não cabe o length (8 bytes), processa bloco atual e começa novo
    if (_bufferLength > 56) {
      while (_bufferLength < 64) {
        _buffer[_bufferLength++] = 0;
      }
      _processBlock(_buffer);
      _bufferLength = 0;
    }

    // Pad com zeros até posição 56
    while (_bufferLength < 56) {
      _buffer[_bufferLength++] = 0;
    }

    // Append length em bits (big-endian 64-bit)
    _buffer[56] = (bitLength >> 56) & 0xFF;
    _buffer[57] = (bitLength >> 48) & 0xFF;
    _buffer[58] = (bitLength >> 40) & 0xFF;
    _buffer[59] = (bitLength >> 32) & 0xFF;
    _buffer[60] = (bitLength >> 24) & 0xFF;
    _buffer[61] = (bitLength >> 16) & 0xFF;
    _buffer[62] = (bitLength >> 8) & 0xFF;
    _buffer[63] = bitLength & 0xFF;

    _processBlock(_buffer);

    // Converte estado para bytes (big-endian)
    final digest = Uint8List(32);
    for (int i = 0; i < 8; i++) {
      digest[i * 4] = (_state[i] >> 24) & 0xFF;
      digest[i * 4 + 1] = (_state[i] >> 16) & 0xFF;
      digest[i * 4 + 2] = (_state[i] >> 8) & 0xFF;
      digest[i * 4 + 3] = _state[i] & 0xFF;
    }

    return digest;
  }

  /// Hash de uma vez só (convenience method)
  static Uint8List hash(Uint8List data) {
    final sha = Sha256Asm();
    sha.update(data);
    return sha.finalize();
  }

  /// Processa um bloco de 64 bytes
  void _processBlock(Uint8List block) {
    // Por enquanto, usa implementação software otimizada
    // TODO: Implementar versão SHA-NI quando estiver testada
    _processBlockSoftware(block);
  }

  /// Implementação software otimizada do processamento de bloco
  void _processBlockSoftware(Uint8List block) {
    // Message schedule array
    final w = Uint32List(64);

    // Carrega primeiras 16 palavras do bloco (big-endian)
    for (int i = 0; i < 16; i++) {
      w[i] = (block[i * 4] << 24) |
          (block[i * 4 + 1] << 16) |
          (block[i * 4 + 2] << 8) |
          block[i * 4 + 3];
    }

    // Expande para 64 palavras
    for (int i = 16; i < 64; i++) {
      final s0 = _rotr(w[i - 15], 7) ^ _rotr(w[i - 15], 18) ^ (w[i - 15] >> 3);
      final s1 = _rotr(w[i - 2], 17) ^ _rotr(w[i - 2], 19) ^ (w[i - 2] >> 10);
      w[i] = (w[i - 16] + s0 + w[i - 7] + s1) & 0xFFFFFFFF;
    }

    // Inicializa variáveis de trabalho
    int a = _state[0];
    int b = _state[1];
    int c = _state[2];
    int d = _state[3];
    int e = _state[4];
    int f = _state[5];
    int g = _state[6];
    int h = _state[7];

    // 64 rounds
    for (int i = 0; i < 64; i++) {
      final s1 = _rotr(e, 6) ^ _rotr(e, 11) ^ _rotr(e, 25);
      final ch = (e & f) ^ ((~e & 0xFFFFFFFF) & g);
      final temp1 = (h + s1 + ch + _sha256K[i] + w[i]) & 0xFFFFFFFF;
      final s0 = _rotr(a, 2) ^ _rotr(a, 13) ^ _rotr(a, 22);
      final maj = (a & b) ^ (a & c) ^ (b & c);
      final temp2 = (s0 + maj) & 0xFFFFFFFF;

      h = g;
      g = f;
      f = e;
      e = (d + temp1) & 0xFFFFFFFF;
      d = c;
      c = b;
      b = a;
      a = (temp1 + temp2) & 0xFFFFFFFF;
    }

    // Adiciona ao estado
    _state[0] = (_state[0] + a) & 0xFFFFFFFF;
    _state[1] = (_state[1] + b) & 0xFFFFFFFF;
    _state[2] = (_state[2] + c) & 0xFFFFFFFF;
    _state[3] = (_state[3] + d) & 0xFFFFFFFF;
    _state[4] = (_state[4] + e) & 0xFFFFFFFF;
    _state[5] = (_state[5] + f) & 0xFFFFFFFF;
    _state[6] = (_state[6] + g) & 0xFFFFFFFF;
    _state[7] = (_state[7] + h) & 0xFFFFFFFF;
  }

  /// Rotate right
  static int _rotr(int x, int n) {
    return ((x >> n) | (x << (32 - n))) & 0xFFFFFFFF;
  }
}

/// HMAC-SHA256 otimizado
class HmacSha256Asm {
  final Uint8List _ipad;
  final Uint8List _opad;

  HmacSha256Asm(Uint8List key)
      : _ipad = Uint8List(64),
        _opad = Uint8List(64) {
    // Prepara a chave
    Uint8List preparedKey;
    if (key.length > 64) {
      // Hash key se maior que block size
      preparedKey = Sha256Asm.hash(key);
    } else {
      preparedKey = key;
    }

    // Prepara ipad e opad
    for (int i = 0; i < 64; i++) {
      final k = i < preparedKey.length ? preparedKey[i] : 0;
      _ipad[i] = k ^ 0x36;
      _opad[i] = k ^ 0x5C;
    }
  }

  /// Calcula HMAC
  Uint8List compute(Uint8List data) {
    // Inner hash: H(ipad || data)
    final innerSha = Sha256Asm();
    innerSha.update(_ipad);
    innerSha.update(data);
    final innerHash = innerSha.finalize();

    // Outer hash: H(opad || inner_hash)
    final outerSha = Sha256Asm();
    outerSha.update(_opad);
    outerSha.update(innerHash);
    return outerSha.finalize();
  }
}
